# Dispatch Developer Rules

## 1. Core Principle

Nothing should be hardcoded in the service layer if the data already has a real source of truth.

## 2. Coordinate Field Naming

**MANDATORY:** Use consistent coordinate field names across all code, models, handlers, services, tests, and documentation.

### Required Fields

**Origin (Pickup):**
- `origin_lat` - Latitude
- `origin_lng` - Longitude

**Destination (Drop):**
- `destination_lat` - Latitude
- `destination_lng` - Longitude

### Rules

✅ **USE:** `origin_lat`, `origin_lng`, `destination_lat`, `destination_lng`  
❌ **FORBIDDEN:** `pickup_lat`, `pickup_lng`, `drop_lat`, `drop_lng`

### Format

- **Case:** snake_case
- **Type:** `float64`
- **Optional:** Yes (`omitempty`)

### Applies To

Event schemas, Go structs, handlers, services, tests, fixtures, mocks, docs, all event payloads.

**Go:**
```go
type ServiceabilityFoundEvent struct {
    OriginLat      float64 `json:"origin_lat,omitempty"`
    OriginLng      float64 `json:"origin_lng,omitempty"`
    DestinationLat float64 `json:"destination_lat,omitempty"`
    DestinationLng float64 `json:"destination_lng,omitempty"`
}
```

## 3. ID Format Specifications (Dispatch Network)

**MANDATORY:** All IDs in the Dispatch Network follow specific format rules for consistency, readability, and business logic.

### ID Format Rules

#### rider_id
- **Format:** `{State Code}{City Code}{YY}{5-digit incremental number}`
- **Example:** `MH122500001`
  - `MH` = Maharashtra (State Code)
  - `12` = City Code
  - `25` = Year (2025)
  - `00001` = 5-digit incremental number
- **Purpose:** Rider identification with geographic and temporal context
- **Generated By:** Rider Auth Service
- **Storage:** UUID in database, formatted ID in business logic

#### client_id
- **Format:** `{3 characters of Name}{Type}`
- **Example:** `ZOMFOOD`
  - `ZOM` = First 3 characters of client name (Zomato)
  - `FOOD` = Client type
- **Purpose:** Client/tenant identification
- **Generated By:** Admin Service / Client Onboarding
- **Storage:** String identifier

#### dispatch_order_id
- **Format:** `{3 characters of client name}{9-digit incremental number}`
- **Example:** `ZOM000000001`, `SWG000000123`
  - `ZOM` = 3 characters of client name (Zomato)
  - `000000001` = 9-digit incremental number (padded with zeros)
- **Purpose:** Order identification with client context
- **Generated By:** Order Service (incremental per client)
- **Storage:** String identifier in `orders.orders.dispatch_order_id`
- **Increment:** Sequential per client (client-specific counter)

### ID Format Rules Summary

| ID Type | Format Pattern | Example | Generated By |
|---------|---------------|---------|--------------|
| `rider_id` | `{State}{City}{YY}{5-digit}` | `MH122500001` | Rider Auth Service |
| `client_id` | `{3-char name}{Type}` | `ZOMFOOD` | Admin Service |
| `dispatch_order_id` | `{3-char client}{9-digit}` | `ZOM000000001` | Order Service |

### Implementation Notes

- **dispatch_order_id**: Order Service maintains per-client incremental counters
- **rider_id**: Format is business-readable; internal storage may use UUID
- **client_id**: Immutable after creation; used for tenant isolation
- All IDs are case-sensitive strings
- Incremental numbers are zero-padded to maintain fixed length

## 4. ID Stack Architecture

### Final ID Stack
```
┌────────────────────────────────────┐
│ trace_id                           │  ← observability (SRE, OpenTelemetry)
├────────────────────────────────────┤
│ correlation_id                     │  ← UI / session / conversation (WebSocket)
├────────────────────────────────────┤
│ client_id                          │  ← tenant boundary (auth, billing)
├────────────────────────────────────┤
│ search_id / quote_id /             │
│ dispatch_order_id                  │  ← business lifecycle
├────────────────────────────────────┤
│ event_id                           │  ← event-level idempotency
├────────────────────────────────────┤
│ message_id (Redis Stream ID)       │  ← transport sequencing
└────────────────────────────────────┘
```

### One-line meaning
- **trace_id** → *What happened across services*
- **correlation_id** → *What belongs to one UI/session*
- **client_id** → *Who owns this business*
- **business IDs** → *What the business object is*
- **event_id** → *Did we already process this event*
- **message_id** → *Where is this message in the stream*

### System Boundaries
```
CLIENT ──► UOIS GATEWAY ──► CORE SERVICES ──► WEBSOCKET ──► RIDER APP
search_id,          trace_id,         business IDs,         correlation_id,
quote_id,           client_id         client_id,            dispatch_order_id
dispatch_order_id                    trace_id
                                    event_id
```

### Strict Rules (Non-Negotiable)
- **trace_id**: Generated once at UOIS, propagated everywhere, logs + spans only
- **correlation_id**: Generated by WebSocket Gateway, UI session scope only
- **client_id**: Extracted from auth, tenant boundary, never user-editable
- **business IDs**: Pure lifecycle progression, client sees one at a time
- **event_id**: Generated by publisher, deduplication only, TTL-based
- **message_id**: Redis-generated, ACK/replay only, never business logic

### One-Line Law
> **Core domain services operate only on business IDs + client_id, observability uses trace_id, event delivery uses event_id, and UI/session coordination uses correlation_id exclusively at the WebSocket boundary.**

## 5. State Architecture (Canonical State Model)

**MANDATORY:** All order state transitions must follow the canonical state machine defined in the Order Service.

### Canonical Order States (Order Service)

**Purpose:** Durable, persisted business state representing what actually happened to the order
**Storage:** Order Service database (`orders.orders.state`) - single source of truth
**Consumers:** All services (analytics, billing, orchestration, recovery, Rider Gateway)

**Current States (22):**
```text
CREATED, ASSIGNED, ACCEPTED, EN_ROUTE_TO_ORIGIN,
SOFT_ARRIVED_AT_ORIGIN, HARD_ARRIVED_AT_ORIGIN, PICKED_UP,
EN_ROUTE_TO_DESTINATION, SOFT_ARRIVED_AT_DESTINATION,
HARD_ARRIVED_AT_DESTINATION, DELIVERY_ATTEMPTED,
PAYMENT_COLLECTED, DELIVERED, CANCELLED, CANCELLED_D,
ASSIGNMENT_FAILED, EXPIRED, RTO_INITIATED, RTO_DELIVERED,
MDND, COMPLETED, REASSIGNED
```

**Category Breakdown:**

**Pre-Assignment (2):**
- `CREATED`, `ASSIGNED`

**Rider Journey - Pickup (5):**
- `ACCEPTED`, `EN_ROUTE_TO_ORIGIN`, `SOFT_ARRIVED_AT_ORIGIN`, `HARD_ARRIVED_AT_ORIGIN`, `PICKED_UP`

**Rider Journey - Delivery (5):**
- `EN_ROUTE_TO_DESTINATION`, `SOFT_ARRIVED_AT_DESTINATION`, `HARD_ARRIVED_AT_DESTINATION`, `DELIVERY_ATTEMPTED`, `PAYMENT_COLLECTED`

**Completion (3):**
- `DELIVERED`, `RTO_DELIVERED`, `COMPLETED`

**Exceptions (7):**
- `CANCELLED`, `CANCELLED_D`, `ASSIGNMENT_FAILED`, `EXPIRED`, `RTO_INITIATED`, `MDND`, `REASSIGNED`

**Rules:**
- ✅ **MUST** be persisted in database (`orders.orders.state`)
- ✅ **MUST** represent actual business state
- ✅ **MUST** be used for recovery, retries, and analytics
- ✅ **MUST** follow state machine transition rules (`domain.CanTransition()`)
- ❌ **MUST NOT** skip required state transitions
- ❌ **MUST NOT** create states outside this canonical set

### State Transition Sources

**Geofence Auto-Transitions (Location Service → Redis Stream):**
- `SOFT_ARRIVED_AT_ORIGIN`
- `SOFT_ARRIVED_AT_DESTINATION`

**Rider Manual Actions (Rider App → WebSocket Gateway → gRPC):**
- `ACCEPTED`, `EN_ROUTE_TO_ORIGIN`, `HARD_ARRIVED_AT_ORIGIN`, `PICKED_UP`
- `EN_ROUTE_TO_DESTINATION`, `HARD_ARRIVED_AT_DESTINATION`, `DELIVERED`
- `DELIVERY_ATTEMPTED`, `PAYMENT_COLLECTED`

**System/Assignment Events (DroneAI → Redis Stream):**
- `ASSIGNED`, `REASSIGNED`, `ASSIGNMENT_FAILED`, `EXPIRED`

**Completion/Admin Actions:**
- `COMPLETED`, `CANCELLED`, `CANCELLED_D`, `RTO_INITIATED`, `RTO_DELIVERED`, `MDND`

### Domain Events (Transient Signals)

**Purpose:** Momentary signals that something occurred, used to trigger side effects
**Storage:** Redis Streams (transient)
**Consumers:** Multiple services (Rider Gateway, analytics, notifications)

**Published Events:**
```text
RIDER_ASSIGNED, RIDER_ACCEPTED, ORDER_PICKED_UP, ORDER_DELIVERED,
ORDER_COMPLETED, ORDER_CANCELLED, RTO_INITIATED, RTO_DELIVERED,
PAYMENT_COLLECTED, DELIVERY_ATTEMPTED, REASSIGNED
```

**Rules:**
- ✅ **MUST** be signals, not current state
- ✅ **MUST** be used for side effects and cross-service coordination
- ✅ **MAY** be consumed by multiple services independently
- ✅ **MAY** be discarded after TTL
- ❌ **MUST NOT** be treated as order state
- ❌ **MUST NOT** be used as source of truth for recovery

### Critical Design Principle

> **Order Service owns and persists all 22 canonical order states.**
> **State transitions are triggered by events from multiple sources (Location Service, Rider App, DroneAI, system).**
> **The state machine enforces valid transitions and prevents invalid state changes.**

### Implementation Law

> **Order Service is the single source of truth for order state.**
> **All state transitions must go through `domain.CanTransition()` validation.**
> **Events are triggers, not states—they cause state transitions but are not persisted as order state.**

### Common Mistakes (FORBIDDEN)

❌ **Skipping intermediate states in the state machine**
❌ **Allowing transitions not defined in `domain.CanTransition()`**
❌ **Persisting event names as order state**
❌ **Creating new states without updating the state machine**
❌ **Bypassing state validation in handlers**

### Correct Examples

✅ **State Transition:** `ASSIGNED` → rider accepts → `ACCEPTED` (state persisted in DB)
✅ **Event Publishing:** State changed to `ACCEPTED` → publish `RIDER_ACCEPTED` event (transient signal)
✅ **State Machine:** Every transition validated via `domain.CanTransition()` before DB update
✅ **Recovery:** Read `orders.orders.state` to determine current state, not from events

