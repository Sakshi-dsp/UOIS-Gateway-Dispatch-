# Cursor Development Rules

## 1. Code Quality & Structure

### File/Package Rules

- Keep packages small and domain-focused (handlers, services, repository, clients, utils, config).

- No cross-package circular imports.

- Never expose internal structures across layers — use DTOs.

- Avoid "God files" — split handlers/services logically.

### DRY Principle

- Do not violate DRY (Don't Repeat Yourself) principle.

- Extract common logic into reusable functions, utilities, or shared packages.

- Refactor duplicated code into shared components before adding new features.

- When you find yourself copying code, stop and create a reusable abstraction instead.

## 2. Keep every function under 20 lines.

### Function/Method Rules

Functions must be:

- < 20–25 lines

- Single-responsibility

- Named with verbs for actions (GetRider, ProcessCancel, ValidateOTP)

- Follow PEP 8 analogs for Go: clear naming, consistent formatting, explicit error handling.

## 3. Architecture & Patterns

- Follow Clean Architecture layering.

  - Handlers: validate input, invoke services, shape HTTP responses.

  - Services: contain business logic, orchestration, integrations.

  - Utils: shared helpers only (serialization, validation, adapters).

- Enforce dependency injection: handlers receive services through constructors; services receive repositories/clients the same way.

- Maintain single responsibility per component; no mixed concerns.

- Centralize shared logic (validation, formatting) instead of duplicating.

- Use Dependency Injection for services

## 4. Observability

- Logging Requirements: Log level: INFO for user actions, WARN for retries, ERROR for failures

- Only one layer should log the error (ideally the handler or an infra boundary)

- Avoid: "Logging AND returning" (double logging)

## 5. Maintainability

- Consistent handler/service structure across all modules.

- Modular layout for easy replacement of individual endpoints or integrations.

- Reuse helpers for date validation, amount checks, and error formatting.

- Ensure each component is independently testable

## 6. Follow strict Test Driven Development principles:

### TDD + Build Rules

All implementation must follow TDD (Test Driven Development):

For each requirement/feature:

- Follow existing patterns, naming conventions, and architecture

- Write/extend tests first

- Identify or create the correct test file(s) following existing naming and structure

- Run tests and ensure green

- Never leave the repo in a broken state between steps

- Once tests pass, that feature/requirement is considered implemented for this iteration

- After each successful test run, the repo must be in a buildable and working state

- Only then, move to the next feature

- Implementation must be incremental

### Testing Principles

- Write test before developments

- Use descriptive test names

- Mock all external dependencies

- No real network / no real DB calls

Cover all scenarios:

- success case

- missing headers

- invalid signature

- malformed JSON

- validation failure

- service failure

- correct 200 response

## 7. Go Modules & Dependencies

- Keep go modules clean: `go mod tidy`

- Pin versions carefully (no `-latest`)

- Avoid too many third-party dependencies

## 8. Error Handling

- Always wrap errors using `%w` so the upstream layer can unwrap and inspect the original cause

- Only one layer should log the error (ideally the handler or an infra boundary)

- Avoid: "Logging AND returning" (double logging)

## 9. Context Management

- Never store context inside structs

## General Rule – No Hardcoded Business Values

Never hardcode any business logic values in the codebase.

If you're adding a fallback value or assuming a constant, ALWAYS ask

## 11. ID Domain Isolation & Mapping Prohibition (CRITICAL)

- UOIS Gateway must **NEVER hardcode any business values**, identifiers, enums, states, IDs, or domain assumptions.
- UOIS Gateway must **NEVER introduce fallback values** for any business-critical field.
  - If a required value is missing or invalid → fail fast.
  - Silent defaults, assumptions, or inferred values are strictly forbidden.

- UOIS Gateway is **ONLY responsible for field name and schema mapping** between protocols.
  - Example: ONDC/Beckn field → internal contract field
  - This applies to **keys, structure, and format only**

- **ID mapping is strictly forbidden** in UOIS Gateway.
  - Client / ONDC IDs and Dispatch internal IDs belong to **different domains**
  - IDs must never be:
    - reused
    - derived
    - translated
    - inferred
    - equated
    - hardcoded

- UOIS Gateway may **store ID references only for routing and correlation**, never for semantic meaning.
  - Stored references do NOT imply equality or ownership
  - No ID transformation logic is allowed

- ID ownership rules:
  - UOIS Gateway **generates only IDs it owns** (e.g., search_id, trace_id, event_id)
  - Client-provided IDs are **passed through unchanged**
  - Internal service IDs are **accepted only from owning services**

- Any code that:
  - derives an ID from payload fields
  - reuses protocol IDs as business IDs
  - assumes equivalence across domains  
  is considered a **hard violation of architecture rules** and must be rejected in review.


